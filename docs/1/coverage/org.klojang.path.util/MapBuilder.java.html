<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang Invoke</a> &gt; <a href="index.source.html" class="el_package">org.klojang.path.util</a> &gt; <span class="el_source">MapBuilder.java</span></div><h1>MapBuilder.java</h1><pre class="source lang-java linenums">package org.klojang.path.util;

import org.klojang.check.Check;
import org.klojang.check.Tag;
import org.klojang.check.aux.Result;
import org.klojang.path.Path;

import java.util.*;

import static org.klojang.check.CommonChecks.*;
import static org.klojang.check.CommonExceptions.STATE;
import static org.klojang.check.CommonProperties.strlen;
import static org.klojang.util.ObjectMethods.ifNull;
import static org.klojang.util.ObjectMethods.replaceIf;

/**
 * &lt;p&gt;An elaborate {@code Builder} for {@code Map&lt;String, Object&gt;} pseudo-objects. A
 * {@code MapBuilder} lets you write deeply nested values without having to create
 * the intermediate maps first. If they are missing, they will tacitly be created.
 * Map keys must not be {@code null} or an empty string. Map values can be anything,
 * including {@code null}.
 *
 * &lt;p&gt;Internally, a {@code MapBuilder} works with {@link Path} objects. See the
 * documentation for the {@code Path} class for how to specify path strings.
 *
 * &lt;p&gt;&lt;b&gt;Example 1:&lt;/b&gt;
 *
 * &lt;blockquote&gt;&lt;pre&gt;{@code
 * MapBuilder mb = new MapBuilder();
 * mb.set(&quot;person.address.street&quot;, &quot;12 Revolutionary Rd.&quot;)
 *  .set(&quot;person.address.state&quot;, &quot;CA&quot;)
 *  .set(&quot;person.firstName&quot;, &quot;John&quot;)
 *  .set(&quot;person.lastName&quot;, &quot;Smith&quot;)
 *  .set(&quot;person.dateOfBirth&quot;, LocalDate.of(1967, 4, 4));
 * Map&lt;String, Object&gt; map = mb.createMap();
 * }&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;&lt;b&gt;Example 2:&lt;/b&gt;
 *
 * &lt;blockquote&gt;&lt;pre&gt;{@code
 * Map&lt;String, Object&gt; map = new MapBuilder()
 *  .in(&quot;person&quot;)
 *    .set(&quot;firstName&quot;, &quot;John&quot;)
 *    .set(&quot;lastName&quot;, &quot;Smith&quot;)
 *    .set(&quot;dateOfBirth&quot;, LocalDate.of(1967, 4, 4))
 *    .in(&quot;address&quot;)
 *      .set(&quot;street&quot;, &quot;12 Revolutionary Rd.&quot;)
 *      .set(&quot;state&quot;, &quot;CA&quot;)
 *      .up(&quot;person&quot;)
 *    .in(&quot;medical_status&quot;)
 *      .set(&quot;allergies&quot;, false)
 *      .set(&quot;smoker&quot;, true)
 *      .set(&quot;prescriptions&quot;, null)
 *  .createMap();
 * }&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * @author Ayco Holleman
 */
public final class MapBuilder {

  /**
   * Thrown when trying to write to a path that has already been set, or that extends
   * beyond a path segment with a terminal value (anything other than a map).
   *
   * @author Ayco Holleman
   */
  public static class PathBlockedException extends IllegalArgumentException {

    private PathBlockedException(Path path, Object value) {
<span class="fc" id="L70">      super(createMessage(path, value));</span>
<span class="fc" id="L71">    }</span>

    private PathBlockedException(String msg) {
<span class="fc" id="L74">      super(msg);</span>
<span class="fc" id="L75">    }</span>

    private static String createMessage(Path path, Object value) {
<span class="fc" id="L78">      String fmt = &quot;path \&quot;%s\&quot; blocked by terminal value %s&quot;;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">      if (value instanceof String s) {</span>
<span class="fc" id="L80">        value = '&quot;' + s + '&quot;';</span>
      }
<span class="fc" id="L82">      return String.format(fmt, path, value);</span>
    }

  }

  /*
   * When setting a path, or when processing the source map passed to the
   * constructor, we replace null with this value. This way, if Map.get(key) returns
   * null, we know for sure that the map does not contain the key. No need to follow
   * it up with a containsKey call. On its way out, _NULL_ is replaced again with
   * null.
   */
<span class="fc" id="L94">  private static final Object _NULL_ = new Object();</span>

  private static final String ERR_HOME_ALREADY = &quot;already in root map&quot;;

  /**
   * Creates a new {@code MapBuilder}.
   *
   * @return a new {@code MapBuilder}
   */
  public static MapBuilder begin() {
<span class="fc" id="L104">    return new MapBuilder();</span>
  }

  /**
   * Creates a {@code MapBuilder} that starts out with the entries in the specified
   * map. The map is read, but not modified.
   *
   * @param map The initial {@code Map}
   * @return a {@code MapBuilder} that starts out with the entries in the specified
   *     map
   */
  public static MapBuilder begin(Map&lt;String, Object&gt; map) {
<span class="fc" id="L116">    return new MapBuilder(map);</span>
  }

  private final Map&lt;String, Object&gt; map;
  private final Path root;
  private final MapBuilder parent;

  /**
   * Creates a new {@code MapBuilder}.
   */
  public MapBuilder() {
<span class="fc" id="L127">    this(new LinkedHashMap&lt;&gt;());</span>
<span class="fc" id="L128">  }</span>

  /**
   * Creates a {@code MapBuilder} that starts out with the entries in the specified
   * map. The map is read, but not modified.
   *
   * @param map The initial {@code Map}
   */
<span class="fc" id="L136">  public MapBuilder(Map&lt;String, Object&gt; map) {</span>
<span class="fc" id="L137">    Check.notNull(map, Tag.MAP);</span>
<span class="fc" id="L138">    this.map = new LinkedHashMap&lt;&gt;(map.size() + 10);</span>
<span class="fc" id="L139">    this.root = Path.empty();</span>
<span class="fc" id="L140">    this.parent = null;</span>
<span class="fc" id="L141">    init(this, map);</span>
<span class="fc" id="L142">  }</span>

<span class="fc" id="L144">  private MapBuilder(Path root, MapBuilder parent) {</span>
<span class="fc" id="L145">    this.root = root;</span>
<span class="fc" id="L146">    this.map = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L147">    this.parent = parent;</span>
<span class="fc" id="L148">  }</span>

  /**
   * &lt;p&gt;Sets the specified path to the specified value. It is not allowed to
   * overwrite the value of a path that has already been set, even if set to
   * {@code null}. If necessary, use {@link #unset(String)} to unset the path's value
   * first.
   *
   * &lt;p&gt;It is not allowed to directly set the path to a value of type {@code Map}.
   * Use the {@link #in(String) in} method to create a new map at the specified path.
   * It is allowed to set a path's value to {@code null}.
   *
   * @param path the path at which to write the value
   * @param value the value
   * @return this {@code MapBuilder}
   */
  public MapBuilder set(String path, Object value) {
<span class="fc" id="L165">    Check.notNull(path, Tag.PATH);</span>
<span class="fc" id="L166">    set(this, Path.from(path), value);</span>
<span class="fc" id="L167">    return this;</span>
  }

  /**
   * &lt;p&gt;Appends the specified element to the {@code Collection} found at the
   * specified path. If the path has not been set yet, it will first be set to an
   * empty list, to which the element will be added. If the path is set to a
   * non-{@code Collection} type, a {@link PathBlockedException} is thrown.
   *
   * @param path the path
   * @param element the element to add to the collection found or created at the
   *     specified path
   * @return this {@code MapBuilder}
   */
  public MapBuilder add(String path, Object element) {
<span class="fc" id="L182">    Check.notNull(path, Tag.PATH);</span>
<span class="fc" id="L183">    Result&lt;Object&gt; result = poll(path);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">    if (result.isAvailable()) {</span>
<span class="fc" id="L185">      Check.on(PathBlockedException::new, result.get(), path)</span>
<span class="fc" id="L186">          .is(instanceOf(), Collection.class)</span>
<span class="fc" id="L187">          .then(o -&gt; ((Collection) o).add(element));</span>
    } else {
<span class="fc" id="L189">      List list = new ArrayList();</span>
<span class="fc" id="L190">      list.add(element);</span>
<span class="fc" id="L191">      set(path, list);</span>
    }
<span class="fc" id="L193">    return this;</span>
  }

  /**
   * Returns a {@link Result} object containing the value of the specified path, or
   * {@link Result#notAvailable} if the path is not set.
   *
   * @param path the path
   * @return a {@link Result} object containing the value of the specified path, or
   *     {@link Result#notAvailable} if the path is not set
   * @see #isSet(String)
   */
  public Result&lt;Object&gt; poll(String path) {
<span class="fc" id="L206">    Check.notNull(path, Tag.PATH);</span>
<span class="fc" id="L207">    return poll(this, Path.from(path));</span>
  }

  /**
   * Returns the value of the specified path if set, else {@code null}.
   *
   * @param path the path
   * @param &lt;T&gt; The type to cast the path's value to
   * @return the value of the specified path if set, else {@code null}
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;T&gt; T get(String path) {
<span class="fc" id="L219">    return (T) poll(path).orElse(null);</span>
  }

  /**
   * Returns a {@code MapBuilder} for the map at the specified path. Once this method
   * has been called, &lt;i&gt;all subsequently specified paths&lt;/i&gt; (including for
   * subsequent calls to {@code in()}) are taken relative to the specified path. If
   * there is no map yet at the specified path, it will be created. Ancestral maps
   * will be created as well, as and when needed. If any of the segments in the path
   * (including the last segment) has already been set, a
   * {@link PathBlockedException} is thrown.
   *
   * @param path the path to be used as the base path. The path will itself be
   *     interpreted as relative to the &lt;i&gt;current&lt;/i&gt; base path
   * @return a {@code MapBuilder} for the map found or created at the specified path
   */
  public MapBuilder in(String path) {
<span class="fc" id="L236">    Check.notNull(path, Tag.PATH);</span>
<span class="fc" id="L237">    return in(this, Path.from(path));</span>
  }

  /**
   * Jumps to another branch in the tree of nested maps. The difference between
   * {@code jump} and {@link #in(String) in} is that the path passed to {@code jump}
   * is always taken as an absolute path (i.e. relative to the root map), while the
   * path passed to {@code in} is taken relative to the path(s) passed to previous
   * calls to {@code in} and {@code jump}.
   *
   * @param path the absolute path to be used as the base path
   * @return a {@code MapBuilder} for the map found or created at the specified path
   * @see #in(String)
   */
  public MapBuilder jump(String path) {
<span class="fc bfc" id="L252" title="All 2 branches covered.">    return parent == null ? in(path) : reset().in(path);</span>
  }

  /**
   * &lt;p&gt;Returns a {@code MapBuilder} for the parent map of the map currently being
   * written. All subsequently specified paths will be taken relative to the parent
   * map's path. An {@link IllegalStateException} is thrown when trying to exit out
   * of the root map. This method must be passed the name of the parent map (the last
   * segment of the parent map's path). An {@link IllegalArgumentException} is thrown
   * if the argument does not equal the parent map's name. This is to make sure you
   * will not accidentally start writing to the wrong map, and it makes the
   * map-building code more intelligible.
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * Map&lt;String, Object&gt; map = new MapBuilder()
   *  .in(&quot;person&quot;)
   *    .set(&quot;firstName&quot;, &quot;John&quot;)
   *    .set(&quot;lastName&quot;, &quot;Smith&quot;)
   *    .in(&quot;address&quot;)
   *      .set(&quot;street&quot;, &quot;12 Revolutionary Rd.&quot;)
   *      .set(&quot;state&quot;, &quot;CA&quot;)
   *      .up(&quot;person&quot;)
   *    .set(&quot;dateOfBirth&quot;, LocalDate.of(1967, 4, 4))
   *  .createMap();
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;You can chain {@code exit} calls. To exit from a map directly under the root
   * map, specify {@code null} or {@code &quot;&quot;} (an empty string):
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * MapBuilder mb = new MapBuilder();
   *  .in(&quot;department.manager.address&quot;)
   *    .set(&quot;street&quot;, &quot;Sunset Blvd&quot;)
   *    .up(&quot;manager&quot;)
   *    .up(&quot;department&quot;)
   *    .up(null)
   *  .set(&quot;foo&quot;, &quot;bar&quot;);
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * @param parent the name of the parent map
   * @return a {@code MapBuilder} for the parent map of the map currently being
   *     written to
   */
  public MapBuilder up(String parent) {
<span class="fc" id="L296">    Check.on(STATE, this.parent).is(notNull(), ERR_HOME_ALREADY);</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">    if (root.size() == 1) {</span>
<span class="fc" id="L298">      Check.that(parent).is(empty(),</span>
          &quot;specify null or \&quot;\&quot; to exit to root map&quot;);
    } else {
<span class="fc" id="L301">      String actual = this.parent.root.segment(-1);</span>
<span class="fc" id="L302">      Check.that(parent).is(EQ(), actual,</span>
          &quot;expected segment: \&quot;${obj}\&quot;; provided segment: \&quot;${arg}\&quot;&quot;);
    }
<span class="fc" id="L305">    return this.parent;</span>
  }

  /**
   * Takes you back to the root map. All paths you specify will be interpreted as
   * absolute paths again.
   *
   * @return a {@code MapBuilder} for the root map
   */
  public MapBuilder reset() {
<span class="fc" id="L315">    Check.on(STATE, parent).is(notNull(), ERR_HOME_ALREADY);</span>
<span class="fc" id="L316">    MapBuilder mb = parent;</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">    while (mb.parent != null) {</span>
<span class="fc" id="L318">      mb = mb.parent;</span>
    }
<span class="fc" id="L320">    return mb;</span>
  }

  /**
   * Returns the current branch within tree of nested {@code Map} objects. That is,
   * the base path relative to which all paths are taken.
   *
   * @return the current branch within tree of nested {@code Map} objects
   */
  public String where() {
<span class="fc" id="L330">    return root.toString();</span>
  }

  /**
   * Returns whether the specified path is set to a terminal value (and hence cannot
   * be extended).
   *
   * @param path the path
   * @return whether it is set to a terminal value
   */
  public boolean isSet(String path) {
<span class="fc" id="L341">    Check.notNull(path);</span>
<span class="fc" id="L342">    return isSet(this, Path.from(path));</span>
  }

  /**
   * Unsets the value of the specified path. If any segment preceding the last
   * segment has a terminal value, or if it is not a key in the map at that point the
   * path, this method returns quietly. If the last segment &lt;i&gt;is&lt;/i&gt; a key, it will
   * be removed.
   *
   * @param path the path to unset.
   * @return this {@code MapBuilder}
   */
  public MapBuilder unset(String path) {
<span class="fc" id="L355">    Check.notNull(path);</span>
<span class="fc" id="L356">    unset(this, Path.from(path));</span>
<span class="fc" id="L357">    return this;</span>
  }

  /**
   * Returns the {@code Map} resulting from the write actions. The returned map is
   * modifiable and retains the order in which the paths (now keys) were written. You
   * can continue to use the {@code MapBuilder} after a call to this method.
   *
   * @return the {@code Map} resulting from the write actions
   */
  public Map&lt;String, Object&gt; createMap() {
<span class="fc" id="L368">    MapBuilder mb = this;</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">    for (; mb.parent != null; mb = mb.parent)</span>
      ;
<span class="fc" id="L371">    return createMap(mb);</span>
  }

  /**
   * Returns a string representation of the map created thus far.
   *
   * @return a string representation of the map created thus far
   */
  @Override
  public String toString() {
<span class="fc" id="L381">    return createMap().toString();</span>
  }

  @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
  private static void init(MapBuilder writer, Map map) {
<span class="fc" id="L386">    map.forEach((key, val) -&gt; processEntry(writer, key, val));</span>
<span class="fc" id="L387">  }</span>

  @SuppressWarnings(&quot;rawtypes&quot;)
  private static void processEntry(MapBuilder writer, Object key, Object val) {
<span class="fc" id="L391">    Check.that(key)</span>
<span class="fc" id="L392">        .isNot(NULL(), &quot;illegal null key in source map&quot;)</span>
<span class="fc" id="L393">        .isNot(empty(), &quot;illegal empty key in source map&quot;)</span>
<span class="fc" id="L394">        .is(instanceOf(), String.class, &quot;illegal key type in source map: ${type}&quot;);</span>
<span class="fc" id="L395">    String k = key.toString();</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">    if (val instanceof Map nested) {</span>
<span class="fc" id="L397">      Path path = writer.root.append(k);</span>
<span class="fc" id="L398">      MapBuilder mb = new MapBuilder(path, writer);</span>
<span class="fc" id="L399">      writer.map.put(k, mb);</span>
<span class="fc" id="L400">      init(mb, nested);</span>
<span class="fc" id="L401">    } else {</span>
<span class="fc" id="L402">      Check.that(val).isNot(instanceOf(), MapBuilder.class); // stifle nasty usage</span>
<span class="fc" id="L403">      writer.map.put(k, ifNull(val, _NULL_));</span>
    }
<span class="fc" id="L405">  }</span>

  private static void set(MapBuilder writer, Path path, Object val) {
<span class="fc" id="L408">    String key = firstSegment(path);</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">    if (path.size() == 1) {</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">      if (writer.map.containsKey(key)) {</span>
<span class="fc" id="L411">        throw alreadySet(writer, key);</span>
      }
<span class="fc" id="L413">      Check.that(val, Tag.VALUE)</span>
<span class="fc" id="L414">          .isNot(instanceOf(), Map.class)</span>
<span class="fc" id="L415">          .isNot(instanceOf(), MapBuilder.class); // stifle nasty usage</span>
<span class="fc" id="L416">      writer.map.put(key, ifNull(val, _NULL_));</span>
    } else {
<span class="fc" id="L418">      set(getNestedWriter(writer, key), path.shift(), val);</span>
    }
<span class="fc" id="L420">  }</span>

  private static Result&lt;Object&gt; poll(MapBuilder writer, Path path) {
<span class="fc" id="L423">    String key = path.segment(0);</span>
<span class="fc" id="L424">    Object val = writer.map.get(key);</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">    if (val instanceof MapBuilder nested) {</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">      if (path.size() == 1) {</span>
<span class="fc" id="L427">        return Result.of(createMap(nested));</span>
      }
<span class="fc" id="L429">      return poll(nested, path.shift());</span>
<span class="fc bfc" id="L430" title="All 4 branches covered.">    } else if (path.size() == 1 &amp;&amp; val != null) {</span>
<span class="fc" id="L431">      return Result.of(replaceIf(val, sameAs(), _NULL_, null));</span>
    }
<span class="fc" id="L433">    return Result.notAvailable();</span>
  }

  private static MapBuilder in(MapBuilder writer, Path path) {
<span class="fc bfc" id="L437" title="All 2 branches covered.">    if (path.isEmpty()) {</span>
<span class="fc" id="L438">      return writer;</span>
    }
<span class="fc" id="L440">    String key = firstSegment(path);</span>
<span class="fc" id="L441">    return in(getNestedWriter(writer, key), path.shift());</span>
  }

  private static boolean isSet(MapBuilder writer, Path path) {
<span class="fc" id="L445">    String key = firstSegment(path);</span>
<span class="fc" id="L446">    Object val = writer.map.get(key);</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">    if (val == null) {</span>
<span class="fc" id="L448">      return false;</span>
<span class="fc bfc" id="L449" title="All 4 branches covered.">    } else if (path.size() == 1 || !(val instanceof MapBuilder)) {</span>
<span class="fc" id="L450">      return true;</span>
    }
<span class="fc" id="L452">    return isSet((MapBuilder) val, path.shift());</span>
  }

  private static void unset(MapBuilder writer, Path path) {
<span class="fc" id="L456">    String key = firstSegment(path);</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">    if (path.size() == 1) {</span>
<span class="fc" id="L458">      writer.map.remove(key);</span>
    } else {
<span class="fc" id="L460">      unset(getNestedWriter(writer, key), path.shift());</span>
    }
<span class="fc" id="L462">  }</span>

  private static Map&lt;String, Object&gt; createMap(MapBuilder writer) {
<span class="fc" id="L465">    int sz = 1 + 4 * writer.map.size() / 3;</span>
<span class="fc" id="L466">    Map&lt;String, Object&gt; m = new LinkedHashMap&lt;&gt;(sz);</span>
<span class="fc" id="L467">    writer.map.forEach((key, val) -&gt; {</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">      if (val instanceof MapBuilder mb) {</span>
<span class="fc" id="L469">        m.put(key, createMap(mb));</span>
      } else {
<span class="fc" id="L471">        m.put(key, replaceIf(val, sameAs(), _NULL_, null));</span>
      }
<span class="fc" id="L473">    });</span>
<span class="fc" id="L474">    return m;</span>
  }

  private static MapBuilder getNestedWriter(MapBuilder writer, String key) {
<span class="fc" id="L478">    Path root = writer.root.append(key);</span>
<span class="fc" id="L479">    Object val = writer.map.computeIfAbsent(key, k -&gt; new MapBuilder(root, writer));</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">    if (val instanceof MapBuilder mb) {</span>
<span class="fc" id="L481">      return mb;</span>
    }
<span class="fc" id="L483">    throw new PathBlockedException(root, val);</span>
  }

  private static PathBlockedException alreadySet(MapBuilder writer,
      String key) {
<span class="fc" id="L488">    Path absPath = writer.root.append(key);</span>
<span class="fc" id="L489">    Object curVal = writer.map.get(key);</span>
<span class="fc" id="L490">    return new PathBlockedException(absPath, curVal);</span>
  }

  private static String firstSegment(Path path) {
<span class="fc" id="L494">    return Check.that(path.segment(0))</span>
<span class="fc" id="L495">        .isNot(NULL(), &quot;illegal null segment in path \&quot;${0}\&quot;&quot;, path)</span>
<span class="fc" id="L496">        .has(strlen(), gt(), 0, &quot;illegal empty segment in path \&quot;${0}\&quot;&quot;, path)</span>
<span class="fc" id="L497">        .ok();</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>